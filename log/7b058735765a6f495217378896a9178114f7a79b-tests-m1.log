make: Entering directory '/home/opam/source/flap/tests-m1'
make -C ..
make[1]: Entering directory '/home/opam/source/flap'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[1]: Leaving directory '/home/opam/source/flap'
make[1]: Entering directory '/home/opam/source/flap/tests-m1/hopix/parser/bad'
========================================================
In parser/bad
GOOD: 0 / 0
[XFAIL]  badapp.hopix

INPUT: 
val x = a b

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  badif.hopix

INPUT: 
val x = if b then b; c else d
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  badlocdef.hopix

INPUT: 
val x =
  val y =
    val z = 1;
    2*z;
  2
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  base-val-no-identifier.hopix

INPUT: 
val = 42

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  lexweird.hopix

INPUT: 
{- Just to check whether 0x and 0b require at least one digit. -}

val x = 0x
val b = 0b

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  lexweird1.hopix

INPUT: 
{- Just to check whether 0x and 0b require at least one digit. -}

val x = 0x

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  lexweird2.hopix

INPUT: 
val b = 0b

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
BAD:  7 / 7
make[1]: Leaving directory '/home/opam/source/flap/tests-m1/hopix/parser/bad'
make[1]: Entering directory '/home/opam/source/flap/tests-m1/hopix/parser/good'
========================================================
In parser/good
[ OK ]   base-val-one.hopix

INPUT:
val x = 1

OUTPUT: 

val x = 1
EXPECTED: 

val x = 1
--------------------------------------------------------
[ OK ]   base-val-var.hopix

INPUT:
val x = 42
val z = x

OUTPUT: 

val x = 42
val z = x
EXPECTED: 

val x = 42
val z = x
--------------------------------------------------------
[ OK ]   comment1.hopix

INPUT:
{- This is a comment -}

val a =
{-
   Another one.
-}
1

val b = 1 {- Still a comment -} + 1


OUTPUT: 

val a = 1
val b = `+ (1, 1)
EXPECTED: 

val a = 1
val b = `+ (1, 1)
--------------------------------------------------------
[ OK ]   comment2.hopix

INPUT:

-- This is also a comment.

val x = 1 + -- Another comment
1

val x = 1 +-- Still a comment
2

val x = 3-- Again...

-- A final comment --

OUTPUT: 

val x = `+ (1, 1)
val x = `+ (1, 2)
val x = 3
EXPECTED: 

val x = `+ (1, 1)
val x = `+ (1, 2)
val x = 3
--------------------------------------------------------
[ OK ]   comment4.hopix

INPUT:
{- This {- is {- a -} {- correctly -} nested -} comment -}

OUTPUT: 


EXPECTED: 


--------------------------------------------------------
[ OK ]   everything.hopix

INPUT:
--    _____                              _      _____   _
--   / ____|                            | |    / ____| | |
--  | |  __   _ __    __ _   _ __     __| |   | (___   | |   __ _   _ __ ___
--  | | |_ | | '__|  / _` | | '_ \   / _` |    \___ \  | |  / _` | | '_ ` _ \
--  | |__| | | |    | (_| | | | | | | (_| |    ____) | | | | (_| | | | | | | |
--   \_____| |_|     \__,_| |_| |_|  \__,_|   |_____/  |_|  \__,_| |_| |_| |_|
--
--
-- This test file is the grand slam ("grand chelem")

{-

   If it passes, you are following the right path: all the language
   constructions have been used at least once, {- including nested
   comments -}.

-}

-------------------------------------------------------------------------------
--                                  Literals                                 --
-------------------------------------------------------------------------------

val i0 = 0
val i1 = 0xcafeCAFE
val i2 = 0XCAFEcafe
val i3 = 0o12345670
val i4 = 0O12345670
val i5 = 0b00101010
val i6 = 0B00101010
val i7 = 42

val helloworld = "\tHelloWorld\n"
val char0 = 'h'
val char1 = '\0x5A'
val char2 = '\022'
val char3 = '\''
val char4 = '\0b00110111'
val char5 = '\0o33'

-------------------------------------------------------------------------------
--                                    Types                                  --
-------------------------------------------------------------------------------

type t0 = I (int)
type t1 ('a) = K ('a)
type t2 ('a, 'b) = A ('a, 'b, 'a -> 'b)
type t3 ('a, 'b) = B ('a -> t2 ('b, t0))
type t4 ('a, 'b) = C (t2 ('a, 'b) -> t0)
type t5 ('a, 'b, 'c) = D ('a -> 'b -> 'c)
type t6 ('a, 'b, 'c) = E (('a -> 'b) -> 'c)
type t7 ('a) = F (t1 ('a))
type t8 ('a) = G (t1 ('a -> t0))

type abs0
type abs1 ('a)
type abs2 ('a, 'b, 'c, 'd)

-------------------------------------------------------------------------------
--                                    External                               --
-------------------------------------------------------------------------------
extern lemming : t8 -> t7

-------------------------------------------------------------------------------
--                                    Functions                              --
-------------------------------------------------------------------------------
fun identity_int (x : int) : int = x
fun identity_int_arrow_int (x : int -> int) : int -> int = x

fun first_int (x : int, y : int) : int = x
fun f (x : int) : int = g (x)
and g (y : int) : int = x

fun identity ['a] (x : 'a) : 'a = x
fun first ['a, 'b] (x : 'a, y : 'b) : 'a = x

-------------------------------------------------------------------------------
--                                    Constructors                           --
-------------------------------------------------------------------------------
val x = I (42)
val y = K [int] (42)
val z = A [int, int] (73, 37, \(x : int) => x)

-------------------------------------------------------------------------------
--                                   Type annotations                       --
-------------------------------------------------------------------------------
val xint = (x : t0)
val somefun = ((\(x) => x) : int -> int)
val applyfun = ((\(f, x) => f (x)) : (int -> int) -> int -> int)

-------------------------------------------------------------------------------
--                                   Sequencing                              --
-------------------------------------------------------------------------------
val two_instructions =
    f (42);
    f (1)

val three_instructions =
    f (42);
    g (31);
    f (1)

-------------------------------------------------------------------------------
--                               Local definitions                           --
-------------------------------------------------------------------------------
val local_val =
    val x = 42;
    x

val local_funs =
    fun f (x) = x and g (x) = x;
    f (42)

-------------------------------------------------------------------------------
--                               Applications                                --
-------------------------------------------------------------------------------
val ft = identity[int] (42)
val firsty = first[int,int] (42, 33)
val infix = 1 + 2
val notinfix = `+ (1, 2)
fun `eats (cat, mouse) = cat
val jerry = 42
val tom = 21
val oh = tom `eats` jerry

-------------------------------------------------------------------------------
--                          Lambda-abstraction                               --
-------------------------------------------------------------------------------
val id = \['a](x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
   \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
   \(x : 'a) => (g (f (x)) : 'c)

-------------------------------------------------------------------------------
--                          If then else                                     --
-------------------------------------------------------------------------------
val if1 = \(x) => if x then f (0)
val if2 = \(x) => if x then f (0) else g (0)
val if3 = \(x) => if x then f (0) elif x then g (0)
val if4 = \(x) => if x then f (0) elif x then g (0) else g (3)
val if5 = \(x) => if x then if x then f (0) elif x then g (0) else g(4) else g (5)

-------------------------------------------------------------------------------
--                          While e { b }                                    --
-------------------------------------------------------------------------------
val while1 =
    \(x) => while x { f (0); f (1) }
OUTPUT: 

val i0 = 0
val i1 = -889271554
val i2 = -889271554
val i3 = 2739128
val i4 = 2739128
val i5 = 42
val i6 = 42
val i7 = 42
val helloworld = "\tHelloWorld\n"
val char0 = 'h'
val char1 = 'Z'
val char2 = '\022'
val char3 = '\''
val char4 = '7'
val char5 = '\027'
type t0  = I (int)
type t1 ('a) = K ('a)
type t2 ('a, 'b) = A ('a , 'b , 'a -> 'b)
type t3 ('a, 'b) = B ('a -> t2 ('b, t0))
type t4 ('a, 'b) = C (t2 ('a, 'b) -> t0)
type t5 ('a, 'b, 'c) = D ('a -> 'b -> 'c)
type t6 ('a, 'b, 'c) = E (('a -> 'b) -> 'c)
type t7 ('a) = F (t1 ('a))
type t8 ('a) = G (t1 ('a -> t0))
type abs0  
type abs1 ('a) 
type abs2 ('a, 'b, 'c, 'd) 
extern lemming : t8 -> t7
fun identity_int (x : int) = (x : int)
fun identity_int_arrow_int (x : int -> int) = (x : int -> int)
fun first_int (x : int, y : int) = (x : int)
fun f (x : int) = (g (x) : int)
and g (y : int) = (x : int)
fun identity ['a] (x : 'a) = (x : 'a)
fun first ['a, 'b] (x : 'a, y : 'b) = (x : 'a)
val x = I (42)
val y = K[int] (42)
val z = A[int, int] (73, 37, \(x : int) => x)
val xint = (x : t0)
val somefun = (\(x) => x : int -> int)
val applyfun = (\(f, x) => f (x) : (int -> int) -> int -> int)
val two_instructions = val nothing = f (42) ; f (1)
val three_instructions =
  val nothing = f (42) ; val nothing = g (31) ; f (1)
val local_val = val x = 42 ; x
val local_funs =
  fun f (x) = x
  and g (x) = x
  ;
  f (42)
val ft = identity[int] (42)
val firsty = first[int, int] (42, 33)
val infix = `+ (1, 2)
val notinfix = `+ (1, 2)
fun `eats (cat, mouse) = cat
val jerry = 42
val tom = 21
val oh = `eats (tom, jerry)
val id = \['a] (x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
  \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
  \(x : 'a) => (g (f (x)) : 'c)
val if1 = \(x) => if x then f (0)
val if2 = \(x) => if x then f (0) else g (0)
val if3 = \(x) => if x then f (0) elif x then g (0)
val if4 = \(x) => if x then f (0) elif x then g (0) else g (3)
val if5 =
  \(x) =>
  if x then (if x then f (0) elif x then g (0) else g (4))
  else
  g (5)
val while1 = \(x) => while x {  val nothing = f (0) ; f (1)  }
EXPECTED: 

val i0 = 0
val i1 = -889271554
val i2 = -889271554
val i3 = 2739128
val i4 = 2739128
val i5 = 42
val i6 = 42
val i7 = 42
val helloworld = "\tHelloWorld\n"
val char0 = 'h'
val char1 = 'Z'
val char2 = '\022'
val char3 = '\''
val char4 = '7'
val char5 = '\027'
type t0  = I (int)
type t1 ('a) = K ('a)
type t2 ('a, 'b) = A ('a , 'b , 'a -> 'b)
type t3 ('a, 'b) = B ('a -> t2 ('b, t0))
type t4 ('a, 'b) = C (t2 ('a, 'b) -> t0)
type t5 ('a, 'b, 'c) = D ('a -> 'b -> 'c)
type t6 ('a, 'b, 'c) = E (('a -> 'b) -> 'c)
type t7 ('a) = F (t1 ('a))
type t8 ('a) = G (t1 ('a -> t0))
type abs0  
type abs1 ('a) 
type abs2 ('a, 'b, 'c, 'd) 
extern lemming : t8 -> t7
fun identity_int (x : int) = (x : int)
fun identity_int_arrow_int (x : int -> int) = (x : int -> int)
fun first_int (x : int, y : int) = (x : int)
fun f (x : int) = (g (x) : int)
and g (y : int) = (x : int)
fun identity ['a] (x : 'a) = (x : 'a)
fun first ['a, 'b] (x : 'a, y : 'b) = (x : 'a)
val x = I (42)
val y = K[int] (42)
val z = A[int, int] (73, 37, \(x : int) => x)
val xint = (x : t0)
val somefun = (\(x) => x : int -> int)
val applyfun = (\(f, x) => f (x) : (int -> int) -> int -> int)
val two_instructions = val nothing = f (42) ; f (1)
val three_instructions =
  val nothing = f (42) ; val nothing = g (31) ; f (1)
val local_val = val x = 42 ; x
val local_funs =
  fun f (x) = x
  and g (x) = x
  ;
  f (42)
val ft = identity[int] (42)
val firsty = first[int, int] (42, 33)
val infix = `+ (1, 2)
val notinfix = `+ (1, 2)
fun `eats (cat, mouse) = cat
val jerry = 42
val tom = 21
val oh = `eats (tom, jerry)
val id = \['a] (x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
  \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
  \(x : 'a) => (g (f (x)) : 'c)
val if1 = \(x) => if x then f (0)
val if2 = \(x) => if x then f (0) else g (0)
val if3 = \(x) => if x then f (0) elif x then g (0)
val if4 = \(x) => if x then f (0) elif x then g (0) else g (3)
val if5 =
  \(x) =>
  if x then (if x then f (0) elif x then g (0) else g (4))
  else
  g (5)
val while1 = \(x) => while x {  val nothing = f (0) ; f (1)  }
--------------------------------------------------------
[ OK ]   extern.hopix

INPUT:

extern something : int
extern some_function : int -> (int -> int) -> int


OUTPUT: 

extern something : int
extern some_function : int -> (int -> int) -> int
EXPECTED: 

extern something : int
extern some_function : int -> (int -> int) -> int
--------------------------------------------------------
[ OK ]   extern1.hopix

INPUT:

extern something : int


OUTPUT: 

extern something : int
EXPECTED: 

extern something : int
--------------------------------------------------------
[ OK ]   extern2.hopix

INPUT:
extern some_function : int -> (int -> int) -> int

OUTPUT: 

extern some_function : int -> (int -> int) -> int
EXPECTED: 

extern some_function : int -> (int -> int) -> int
--------------------------------------------------------
[ OK ]   functions.hopix

INPUT:
fun f (x, y) = x + y
fun f (x : int, y : int) : int = x + y

val f : int -> int = \(x) => x + 1
val g = \(x,y) => x+y
val g = \(x) => \(y) => x+y

fun identity ['a] (x : 'a) : 'a = x
fun first ['a, 'b] (x : 'a, y : 'b) : 'a = x

val id = \['a](x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
   \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
   \(x : 'a) => (g (f (x)) : 'c)

OUTPUT: 

fun f (x, y) = `+ (x, y)
fun f (x : int, y : int) = (`+ (x, y) : int)
val f = (\(x) => `+ (x, 1) : int -> int)
val g = \(x, y) => `+ (x, y)
val g = \(x) => \(y) => `+ (x, y)
fun identity ['a] (x : 'a) = (x : 'a)
fun first ['a, 'b] (x : 'a, y : 'b) = (x : 'a)
val id = \['a] (x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
  \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
  \(x : 'a) => (g (f (x)) : 'c)
EXPECTED: 

fun f (x, y) = `+ (x, y)
fun f (x : int, y : int) = (`+ (x, y) : int)
val f = (\(x) => `+ (x, 1) : int -> int)
val g = \(x, y) => `+ (x, y)
val g = \(x) => \(y) => `+ (x, y)
fun identity ['a] (x : 'a) = (x : 'a)
fun first ['a, 'b] (x : 'a, y : 'b) = (x : 'a)
val id = \['a] (x : 'a) => x
val apply = \['a, 'b] (f : 'a -> 'b, x : 'a) => (f (x) : 'b)
val compose =
  \['a, 'b, 'c] (f : 'a -> 'b, g : 'b -> 'c) =>
  \(x : 'a) => (g (f (x)) : 'c)
--------------------------------------------------------
[ OK ]   functions2.hopix

INPUT:
fun f (x : int, y : int) : int = x + y

OUTPUT: 

fun f (x : int, y : int) = (`+ (x, y) : int)
EXPECTED: 

fun f (x : int, y : int) = (`+ (x, y) : int)
--------------------------------------------------------
[ OK ]   functions3.hopix

INPUT:
val f : int -> int = \(x) => x + 1

OUTPUT: 

val f = (\(x) => `+ (x, 1) : int -> int)
EXPECTED: 

val f = (\(x) => `+ (x, 1) : int -> int)
--------------------------------------------------------
[ OK ]   functions4.hopix

INPUT:
val g = \(x,y) => x+y

OUTPUT: 

val g = \(x, y) => `+ (x, y)
EXPECTED: 

val g = \(x, y) => `+ (x, y)
--------------------------------------------------------
[ OK ]   functions5.hopix

INPUT:
val g = \(x) => \(y) => x+y

OUTPUT: 

val g = \(x) => \(y) => `+ (x, y)
EXPECTED: 

val g = \(x) => \(y) => `+ (x, y)
--------------------------------------------------------
[ KO ]   -->  if.hopix

INPUT:
val if1 = if 0 then 0
val if2 = if 0 then 0 else 0
val if3 = if 0 then 0 elif 0 then 0
val if4 = if 0 then 0 elif 0 then 0 else 0
val if5 = if 0 then 0 elif 0 then 0 elif 0 then 0
val if6 = if 0 then 0 elif 0 then 0 elif 0 then 0 else 0

val if3b = if 0 then 0 else if 0 then 0
val if4b = if 0 then 0 else if 0 then 0 else 0
val if5b = if 0 then 0 else if 0 then 0 else if 0 then 0
val if6b = if 0 then 0 else if 0 then 0 else if 0 then 0 else 0

val pri_if1 = if 0 then if 0 then 0 else 0
val pri_if2 = if a || b then 1+2 else f (3)
val ifif = if if a then b else c then d

val ifseq1 = if a then b; c
val ifseq2 = if a then b else c; d
val ifseq3 = if a; b then b

val iflet1 = if a then val x = b; c
val iflet2 = if a then val x = b; c; d
val iflet3 = if a then b else val x = c; d


OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 

val if1 = if 0 then 0
val if2 = if 0 then 0 else 0
val if3 = if 0 then 0 elif 0 then 0
val if4 = if 0 then 0 elif 0 then 0 else 0
val if5 = if 0 then 0 elif 0 then 0 elif 0 then 0
val if6 = if 0 then 0 elif 0 then 0 elif 0 then 0 else 0
val if3b = if 0 then 0 else (if 0 then 0)
val if4b = if 0 then 0 else (if 0 then 0 else 0)
val if5b = if 0 then 0 else (if 0 then 0 else (if 0 then 0))
val if6b =
  if 0 then 0 else (if 0 then 0 else (if 0 then 0 else 0))
val pri_if1 = if 0 then (if 0 then 0 else 0)
val pri_if2 = if `|| (a, b) then `+ (1, 2) else f (3)
val ifif = if if a then b else c then d
val ifseq1 = val nothing = (if a then b) ; c
val ifseq2 = val nothing = (if a then b else c) ; d
val ifseq3 = if val nothing = a ; b then b
val iflet1 = if a then val x = b ; c
val iflet2 = if a then val x = b ; val nothing = c ; d
val iflet3 = if a then b else val x = c ; d
--------------------------------------------------------
[ OK ]   infix.hopix

INPUT:

fun `++ (x, y) = x
val z = 0 `++` 0
val k = `++ (0, 0)
val `eats = \(x,y) => x
fun wow (cat, mouse) = cat `eats` mouse

val apply = \(`op, x, y) => x `op` y
fun apply (`op, x, y) = x `op` y

OUTPUT: 

fun `++ (x, y) = x
val z = `++ (0, 0)
val k = `++ (0, 0)
val `eats = \(x, y) => x
fun wow (cat, mouse) = `eats (cat, mouse)
val apply = \(`op, x, y) => `op (x, y)
fun apply (`op, x, y) = `op (x, y)
EXPECTED: 

fun `++ (x, y) = x
val z = `++ (0, 0)
val k = `++ (0, 0)
val `eats = \(x, y) => x
fun wow (cat, mouse) = `eats (cat, mouse)
val apply = \(`op, x, y) => `op (x, y)
fun apply (`op, x, y) = `op (x, y)
--------------------------------------------------------
[ OK ]   infix1.hopix

INPUT:

fun `++ (x, y) = x

OUTPUT: 

fun `++ (x, y) = x
EXPECTED: 

fun `++ (x, y) = x
--------------------------------------------------------
[ OK ]   infix2.hopix

INPUT:
val z = 0 `++` 0

OUTPUT: 

val z = `++ (0, 0)
EXPECTED: 

val z = `++ (0, 0)
--------------------------------------------------------
[ OK ]   infix3.hopix

INPUT:
val k = `++ (0, 0)

OUTPUT: 

val k = `++ (0, 0)
EXPECTED: 

val k = `++ (0, 0)
--------------------------------------------------------
[ OK ]   infix4.hopix

INPUT:
val `eats = \(x,y) => x

OUTPUT: 

val `eats = \(x, y) => x
EXPECTED: 

val `eats = \(x, y) => x
--------------------------------------------------------
[ OK ]   infix5.hopix

INPUT:
fun wow (cat, mouse) = cat `eats` mouse

OUTPUT: 

fun wow (cat, mouse) = `eats (cat, mouse)
EXPECTED: 

fun wow (cat, mouse) = `eats (cat, mouse)
--------------------------------------------------------
[ OK ]   infix6.hopix

INPUT:

val apply = \ (`op, x, y) => x `op` y

OUTPUT: 

val apply = \(`op, x, y) => `op (x, y)
EXPECTED: 

val apply = \(`op, x, y) => `op (x, y)
--------------------------------------------------------
[ OK ]   infix7.hopix

INPUT:
fun apply (`op, x, y) = x `op` y

OUTPUT: 

fun apply (`op, x, y) = `op (x, y)
EXPECTED: 

fun apply (`op, x, y) = `op (x, y)
--------------------------------------------------------
[ OK ]   lexchar.hopix

INPUT:
val x = 'a'
val x = 'A'
val x = '*'
val x = '@'
val x = '\\'
val x = '\''
val x = '\n'
val x = '\t'
val x = '\b'
val x = '\r'
val x = '\000'
val x = '\001'
val x = '\255'
val x = '\0xFF'
val x = '\0XaB'
val x = '\0x12'
val x = '\0b11001100'
val x = '\0B11001100'

OUTPUT: 

val x = 'a'
val x = 'A'
val x = '*'
val x = '@'
val x = '\\'
val x = '\''
val x = '\n'
val x = '\t'
val x = '\b'
val x = '\r'
val x = '\000'
val x = '\001'
val x = '\255'
val x = '\255'
val x = '\171'
val x = '\018'
val x = '\204'
val x = '\204'
EXPECTED: 

val x = 'a'
val x = 'A'
val x = '*'
val x = '@'
val x = '\\'
val x = '\''
val x = '\n'
val x = '\t'
val x = '\b'
val x = '\r'
val x = '\000'
val x = '\001'
val x = '\255'
val x = '\255'
val x = '\171'
val x = '\018'
val x = '\204'
val x = '\204'
--------------------------------------------------------
[ OK ]   lexchar1.hopix

INPUT:
val x = 'a'

OUTPUT: 

val x = 'a'
EXPECTED: 

val x = 'a'
--------------------------------------------------------
[ OK ]   lexchar10.hopix

INPUT:
val x = '\r'

OUTPUT: 

val x = '\r'
EXPECTED: 

val x = '\r'
--------------------------------------------------------
[ OK ]   lexchar11.hopix

INPUT:
val x = '\000'

OUTPUT: 

val x = '\000'
EXPECTED: 

val x = '\000'
--------------------------------------------------------
[ OK ]   lexchar12.hopix

INPUT:
val x = '\001'

OUTPUT: 

val x = '\001'
EXPECTED: 

val x = '\001'
--------------------------------------------------------
[ OK ]   lexchar13.hopix

INPUT:
val x = '\255'

OUTPUT: 

val x = '\255'
EXPECTED: 

val x = '\255'
--------------------------------------------------------
[ OK ]   lexchar14.hopix

INPUT:
val x = '\0xFF'

OUTPUT: 

val x = '\255'
EXPECTED: 

val x = '\255'
--------------------------------------------------------
[ OK ]   lexchar15.hopix

INPUT:
val x = '\0XaB'

OUTPUT: 

val x = '\171'
EXPECTED: 

val x = '\171'
--------------------------------------------------------
[ OK ]   lexchar16.hopix

INPUT:
val x = '\0x12'

OUTPUT: 

val x = '\018'
EXPECTED: 

val x = '\018'
--------------------------------------------------------
[ OK ]   lexchar17.hopix

INPUT:
val x = '\0b11001100'

OUTPUT: 

val x = '\204'
EXPECTED: 

val x = '\204'
--------------------------------------------------------
[ OK ]   lexchar18.hopix

INPUT:
val x = '\0B11001100'

OUTPUT: 

val x = '\204'
EXPECTED: 

val x = '\204'
--------------------------------------------------------
[ OK ]   lexchar2.hopix

INPUT:
val x = 'A'

OUTPUT: 

val x = 'A'
EXPECTED: 

val x = 'A'
--------------------------------------------------------
[ OK ]   lexchar3.hopix

INPUT:
val x = '*'

OUTPUT: 

val x = '*'
EXPECTED: 

val x = '*'
--------------------------------------------------------
[ OK ]   lexchar4.hopix

INPUT:
val x = '@'

OUTPUT: 

val x = '@'
EXPECTED: 

val x = '@'
--------------------------------------------------------
[ OK ]   lexchar5.hopix

INPUT:
val x = '\\'

OUTPUT: 

val x = '\\'
EXPECTED: 

val x = '\\'
--------------------------------------------------------
[ OK ]   lexchar6.hopix

INPUT:
val x = '\''

OUTPUT: 

val x = '\''
EXPECTED: 

val x = '\''
--------------------------------------------------------
[ OK ]   lexchar7.hopix

INPUT:
val x = '\n'

OUTPUT: 

val x = '\n'
EXPECTED: 

val x = '\n'
--------------------------------------------------------
[ OK ]   lexchar8.hopix

INPUT:
val x = '\t'

OUTPUT: 

val x = '\t'
EXPECTED: 

val x = '\t'
--------------------------------------------------------
[ OK ]   lexchar9.hopix

INPUT:
val x = '\b'

OUTPUT: 

val x = '\b'
EXPECTED: 

val x = '\b'
--------------------------------------------------------
[ OK ]   lexnum.hopix

INPUT:
val x = 0
val x = 1234567890
val x = 0xdeadbee
val x = 0XdeadBEE
val x = 0x12345678
val x = 0xdeadbeef
val x = 0b101010
val x = 0B101010

OUTPUT: 

val x = 0
val x = 1234567890
val x = 233495534
val x = 233495534
val x = 305419896
val x = -559038737
val x = 42
val x = 42
EXPECTED: 

val x = 0
val x = 1234567890
val x = 233495534
val x = 233495534
val x = 305419896
val x = -559038737
val x = 42
val x = 42
--------------------------------------------------------
[ OK ]   lexnum1.hopix

INPUT:
val x = 0

OUTPUT: 

val x = 0
EXPECTED: 

val x = 0
--------------------------------------------------------
[ OK ]   lexnum2.hopix

INPUT:
val x = 1234567890

OUTPUT: 

val x = 1234567890
EXPECTED: 

val x = 1234567890
--------------------------------------------------------
[ OK ]   lexnum3.hopix

INPUT:
val x = 0xdeadbee

OUTPUT: 

val x = 233495534
EXPECTED: 

val x = 233495534
--------------------------------------------------------
[ OK ]   lexnum4.hopix

INPUT:
val x = 0XdeadBEE

OUTPUT: 

val x = 233495534
EXPECTED: 

val x = 233495534
--------------------------------------------------------
[ OK ]   lexnum5.hopix

INPUT:
val x = 0x12345678

OUTPUT: 

val x = 305419896
EXPECTED: 

val x = 305419896
--------------------------------------------------------
[ OK ]   lexnum6.hopix

INPUT:
val x = 0xdeadbeef

OUTPUT: 

val x = -559038737
EXPECTED: 

val x = -559038737
--------------------------------------------------------
[ OK ]   lexnum7.hopix

INPUT:
val x = 0b101010

OUTPUT: 

val x = 42
EXPECTED: 

val x = 42
--------------------------------------------------------
[ OK ]   lexnum8.hopix

INPUT:
{- negative literals -}

val x = -1 - -3
OUTPUT: 

val x = `- (-1, -3)
EXPECTED: 

val x = `- (-1, -3)
--------------------------------------------------------
[ OK ]   lexstring.hopix

INPUT:
val x = ""
val x = "abc"
val x = "**"
val x = "{-"
val x = "-}"
val x = "a\'a"

OUTPUT: 

val x = ""
val x = "abc"
val x = "**"
val x = "{-"
val x = "-}"
val x = "a'a"
EXPECTED: 

val x = ""
val x = "abc"
val x = "**"
val x = "{-"
val x = "-}"
val x = "a'a"
--------------------------------------------------------
[ OK ]   lexstring1.hopix

INPUT:
val x = ""

OUTPUT: 

val x = ""
EXPECTED: 

val x = ""
--------------------------------------------------------
[ OK ]   lexstring2.hopix

INPUT:
val x = "abc"

OUTPUT: 

val x = "abc"
EXPECTED: 

val x = "abc"
--------------------------------------------------------
[ OK ]   lexstring3.hopix

INPUT:
val x = "**"

OUTPUT: 

val x = "**"
EXPECTED: 

val x = "**"
--------------------------------------------------------
[ OK ]   lexstring4.hopix

INPUT:
val x = "{-"

OUTPUT: 

val x = "{-"
EXPECTED: 

val x = "{-"
--------------------------------------------------------
[ OK ]   lexstring5.hopix

INPUT:
val x = "-}"

OUTPUT: 

val x = "-}"
EXPECTED: 

val x = "-}"
--------------------------------------------------------
[ OK ]   lexstring6.hopix

INPUT:
val x = "a\'a"

OUTPUT: 

val x = "a'a"
EXPECTED: 

val x = "a'a"
--------------------------------------------------------
[ OK ]   list.hopix

INPUT:

type list = Cons (int, list) | Nil

fun map (f, l) : list =
  l ?
  | Nil => Nil
  | Cons (x, xs) => Cons (f (x), map (f, xs))


fun append (l1, l2) : list =
  l1 ? Nil => l2 | Cons (x, xs) => Cons (x, append (xs, l2))


fun sum (l1, l2) : list =
  l1 ?
  | Nil => l2 ? { _ => l2 }
  | Cons (x, xs) => l2 ? Cons (y, ys) => Cons (x + y, sum (xs, ys)) | _ => l1

OUTPUT: 

type list  = Cons (int , list) | Nil
fun map
  (f, l) =
  (l ?
  { | Nil => Nil | Cons (x, xs) => Cons (f (x), map (f, xs)) }
  : list)
fun append
  (l1, l2) =
  (l1 ?
  { | Nil => l2 | Cons (x, xs) => Cons (x, append (xs, l2)) }
  : list)
fun sum
  (l1, l2) =
  (l1 ?
  {
  | Nil => l2 ? { | _ => l2 }
  | Cons (x, xs) =>
    l2 ?
    { | Cons (y, ys) => Cons (`+ (x, y), sum (xs, ys)) | _ => l1 }
  }
  : list)
EXPECTED: 

type list  = Cons (int , list) | Nil
fun map
  (f, l) =
  (l ?
  { | Nil => Nil | Cons (x, xs) => Cons (f (x), map (f, xs)) }
  : list)
fun append
  (l1, l2) =
  (l1 ?
  { | Nil => l2 | Cons (x, xs) => Cons (x, append (xs, l2)) }
  : list)
fun sum
  (l1, l2) =
  (l1 ?
  {
  | Nil => l2 ? { | _ => l2 }
  | Cons (x, xs) =>
    l2 ?
    { | Cons (y, ys) => Cons (`+ (x, y), sum (xs, ys)) | _ => l1 }
  }
  : list)
--------------------------------------------------------
[ OK ]   localdef.hopix

INPUT:

val x =
  val y = 1;
  val z = 2;
  y+z

val x = 1 +
  val y = 1;
  val z = 2;
  y + z

val x =
  val a = 1;
  val b = 2;
  3;
  4

val x = 1; 2; 3   {- to be parsed as 1;(2;3) -}

val x = (1; 2); 3

{- We hence need some parenthesis to nest local defs,
   otherwise we stay at the level of the innermost def,
   and end with a parse error. -}

val x =
  val y =
    (val z = 1;
    2*z);
  2

val x =
  val y =
    (val z = 1;
    2*z);
  val t =
    (val u = 2;
    2*u);
  y*t

val even =
  fun even (x) = if x = 0 then true else odd (x-1)
  and odd (x) = if x = 0 then false else even (x-1);
  even

OUTPUT: 

val x = val y = 1 ; val z = 2 ; `+ (y, z)
val x = `+ (1, val y = 1 ; val z = 2 ; `+ (y, z))
val x = val a = 1 ; val b = 2 ; val nothing = 3 ; 4
val x = val nothing = 1 ; val nothing = 2 ; 3
val x = val nothing = (val nothing = 1 ; 2) ; 3
val x = val y = (val z = 1 ; `* (2, z)) ; 2
val x =
  val y = (val z = 1 ; `* (2, z)) ;
  val t = (val u = 2 ; `* (2, u)) ; `* (y, t)
val even =
  fun even (x) = (if `= (x, 0) then true else odd (`- (x, 1)))
  and odd (x) = (if `= (x, 0) then false else even (`- (x, 1)))
  ;
  even
EXPECTED: 

val x = val y = 1 ; val z = 2 ; `+ (y, z)
val x = `+ (1, val y = 1 ; val z = 2 ; `+ (y, z))
val x = val a = 1 ; val b = 2 ; val nothing = 3 ; 4
val x = val nothing = 1 ; val nothing = 2 ; 3
val x = val nothing = (val nothing = 1 ; 2) ; 3
val x = val y = (val z = 1 ; `* (2, z)) ; 2
val x =
  val y = (val z = 1 ; `* (2, z)) ;
  val t = (val u = 2 ; `* (2, u)) ; `* (y, t)
val even =
  fun even (x) = (if `= (x, 0) then true else odd (`- (x, 1)))
  and odd (x) = (if `= (x, 0) then false else even (`- (x, 1)))
  ;
  even
--------------------------------------------------------
[ OK ]   localdef1.hopix

INPUT:

val x =
  val y = 1;
  val z = 2;
  y+z


OUTPUT: 

val x = val y = 1 ; val z = 2 ; `+ (y, z)
EXPECTED: 

val x = val y = 1 ; val z = 2 ; `+ (y, z)
--------------------------------------------------------
[ OK ]   localdef2.hopix

INPUT:
val x = 1 +
  val y = 1;
  val z = 2;
  y + z

OUTPUT: 

val x = `+ (1, val y = 1 ; val z = 2 ; `+ (y, z))
EXPECTED: 

val x = `+ (1, val y = 1 ; val z = 2 ; `+ (y, z))
--------------------------------------------------------
[ OK ]   localdef3.hopix

INPUT:
val x =
  val y =
    (val z = 1;
    2*z);
  val t =
    (val u = 2;
    2*u);
  y*t

OUTPUT: 

val x =
  val y = (val z = 1 ; `* (2, z)) ;
  val t = (val u = 2 ; `* (2, u)) ; `* (y, t)
EXPECTED: 

val x =
  val y = (val z = 1 ; `* (2, z)) ;
  val t = (val u = 2 ; `* (2, u)) ; `* (y, t)
--------------------------------------------------------
[ OK ]   localdef4a.hopix

INPUT:

val even =
  fun even (x) = 1
  and odd (x) = 2;
  even
OUTPUT: 

val even =
  fun even (x) = 1
  and odd (x) = 2
  ;
  even
EXPECTED: 

val even =
  fun even (x) = 1
  and odd (x) = 2
  ;
  even
--------------------------------------------------------
[ OK ]   localdef4b.hopix

INPUT:

val even =
  fun even (x) = if x = 0 then true else odd (x-1)
  and odd (x) = if x = 0 then false else even (x-1);
  even
OUTPUT: 

val even =
  fun even (x) = (if `= (x, 0) then true else odd (`- (x, 1)))
  and odd (x) = (if `= (x, 0) then false else even (`- (x, 1)))
  ;
  even
EXPECTED: 

val even =
  fun even (x) = (if `= (x, 0) then true else odd (`- (x, 1)))
  and odd (x) = (if `= (x, 0) then false else even (`- (x, 1)))
  ;
  even
--------------------------------------------------------
[ OK ]   localdef4c.hopix

INPUT:

val f =
  fun f (x) = 1
  and g (x) = 2
  and h (x) = 3;
  f
OUTPUT: 

val f =
  fun f (x) = 1
  and g (x) = 2
  and h (x) = 3
  ;
  f
EXPECTED: 

val f =
  fun f (x) = 1
  and g (x) = 2
  and h (x) = 3
  ;
  f
--------------------------------------------------------
[ OK ]   match1.hopix

INPUT:

type enum = | A | B | C | D

fun f (x) = x ? A => 1 | B => 2 | C => 3 | D => 4
fun f (x) = x ? A => 1 | B | C | D => 3
fun f (x) = x ? | A => 1 | B | C | D => 3
fun f (x, y) = x ? A => y ? B => C

OUTPUT: 

type enum  = A | B | C | D
fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x, y) = x ? { | A => y ? { | B => C } }
EXPECTED: 

type enum  = A | B | C | D
fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x, y) = x ? { | A => y ? { | B => C } }
--------------------------------------------------------
[ OK ]   match11.hopix

INPUT:

type enum = | A | B | C | D


OUTPUT: 

type enum  = A | B | C | D
EXPECTED: 

type enum  = A | B | C | D
--------------------------------------------------------
[ OK ]   match12.hopix

INPUT:
fun f (x) = x ? A => 1 | B => 2 | C => 3 | D => 4

OUTPUT: 

fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
--------------------------------------------------------
[ OK ]   match13.hopix

INPUT:
fun f (x) = x ? A => 1 | B | C | D => 3
OUTPUT: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
--------------------------------------------------------
[ OK ]   match14.hopix

INPUT:
fun f (x) = x ? | A => 1 | B | C | D => 3

OUTPUT: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
--------------------------------------------------------
[ OK ]   match15.hopix

INPUT:
fun f (x, y) = x ? A => y ? B => C

OUTPUT: 

fun f (x, y) = x ? { | A => y ? { | B => C } }
EXPECTED: 

fun f (x, y) = x ? { | A => y ? { | B => C } }
--------------------------------------------------------
[ OK ]   match2.hopix

INPUT:

type enum = | A | B | C | D

fun f (x) = x ? { A => 1 | B => 2 | C => 3 | D => 4 }
fun f (x) = x ? { A => 1 | B | C | D => 3 }
fun f (x) = x ? { | A => 1 | B | C | D => 3 }
fun f (x, y) = x ? { A => y ? { B => C } }

OUTPUT: 

type enum  = A | B | C | D
fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x, y) = x ? { | A => y ? { | B => C } }
EXPECTED: 

type enum  = A | B | C | D
fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
fun f (x, y) = x ? { | A => y ? { | B => C } }
--------------------------------------------------------
[ OK ]   match21.hopix

INPUT:

type enum = | A | B | C | D

OUTPUT: 

type enum  = A | B | C | D
EXPECTED: 

type enum  = A | B | C | D
--------------------------------------------------------
[ OK ]   match22.hopix

INPUT:

fun f (x) = x ? { A => 1 | B => 2 | C => 3 | D => 4 }

OUTPUT: 

fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | B => 2 | C => 3 | D => 4 }
--------------------------------------------------------
[ OK ]   match23.hopix

INPUT:
fun f (x) = x ? { A => 1 | B | C | D => 3 }

OUTPUT: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
--------------------------------------------------------
[ OK ]   match24.hopix

INPUT:
fun f (x) = x ? { | A => 1 | B | C | D => 3 }

OUTPUT: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
EXPECTED: 

fun f (x) = x ? { | A => 1 | (B | C | D) => 3 }
--------------------------------------------------------
[ OK ]   match25.hopix

INPUT:
fun f (x, y) = x ? { A => y ? { B => C } }

OUTPUT: 

fun f (x, y) = x ? { | A => y ? { | B => C } }
EXPECTED: 

fun f (x, y) = x ? { | A => y ? { | B => C } }
--------------------------------------------------------
[ OK ]   match3.hopix

INPUT:

type enum = | A | B | C | D

fun f (x) = x ? ((A|B)|(C|D)) => 1
fun f (x) = x ? (((A|B)|C)|D) => 1
fun f (x) = x ? (A|(B|(C|D))) => 1

fun f (x) = x ? ((A&B)&(C&D)) => 1
fun f (x) = x ? (((A&B)&C)&D) => 1
fun f (x) = x ? (A&(B&(C&D))) => 1

fun f (x) = x ? (A|B) & y & (B|C) & _ => y
fun f (x) = x ? A | B & y | _ => 1

OUTPUT: 

type enum  = A | B | C | D
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | ((A | B) & y & (B | C) & _) => y }
fun f (x) = x ? { | (A | (B & y) | _) => 1 }
EXPECTED: 

type enum  = A | B | C | D
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A | B | C | D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | (A & B & C & D) => 1 }
fun f (x) = x ? { | ((A | B) & y & (B | C) & _) => y }
fun f (x) = x ? { | (A | (B & y) | _) => 1 }
--------------------------------------------------------
[ OK ]   match31.hopix

INPUT:

type enum = | A | B | C | D

fun f (x) = x ? ((A|B)|(C|D)) => 1

OUTPUT: 

type enum  = A | B | C | D
fun f (x) = x ? { | (A | B | C | D) => 1 }
EXPECTED: 

type enum  = A | B | C | D
fun f (x) = x ? { | (A | B | C | D) => 1 }
--------------------------------------------------------
[ OK ]   match32.hopix

INPUT:
fun f (x) = x ? (((A|B)|C)|D) => 1

OUTPUT: 

fun f (x) = x ? { | (A | B | C | D) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A | B | C | D) => 1 }
--------------------------------------------------------
[ OK ]   match33.hopix

INPUT:
fun f (x) = x ? (A|(B|(C|D))) => 1

OUTPUT: 

fun f (x) = x ? { | (A | B | C | D) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A | B | C | D) => 1 }
--------------------------------------------------------
[ OK ]   match34.hopix

INPUT:
fun f (x) = x ? ((A&B)&(C&D)) => 1

OUTPUT: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
--------------------------------------------------------
[ OK ]   match35.hopix

INPUT:
fun f (x) = x ? (((A&B)&C)&D) => 1

OUTPUT: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
--------------------------------------------------------
[ OK ]   match36.hopix

INPUT:
fun f (x) = x ? (A&(B&(C&D))) => 1

OUTPUT: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A & B & C & D) => 1 }
--------------------------------------------------------
[ OK ]   match37.hopix

INPUT:
fun f (x) = x ? (A|B) & y & (B|C) & _ => y

OUTPUT: 

fun f (x) = x ? { | ((A | B) & y & (B | C) & _) => y }
EXPECTED: 

fun f (x) = x ? { | ((A | B) & y & (B | C) & _) => y }
--------------------------------------------------------
[ OK ]   match38.hopix

INPUT:
fun f (x) = x ? A | B & y | _ => 1

OUTPUT: 

fun f (x) = x ? { | (A | (B & y) | _) => 1 }
EXPECTED: 

fun f (x) = x ? { | (A | (B & y) | _) => 1 }
--------------------------------------------------------
[ OK ]   mutfunseq.hopix

INPUT:

fun f (x) = a; b

and g (x) = c; d

and h (x) = d; e


OUTPUT: 

fun f (x) = val nothing = a ; b
and g (x) = val nothing = c ; d
and h (x) = val nothing = d ; e
EXPECTED: 

fun f (x) = val nothing = a ; b
and g (x) = val nothing = c ; d
and h (x) = val nothing = d ; e
--------------------------------------------------------
[ OK ]   mutrecfun.hopix

INPUT:

fun odd (n : int) : int =
  if n = 0 then false else
  if n = 1 then true else
    even (n - 1)
and even (n : int) : int =
  if n = 0 then true
  elif n = 1 then false else
    odd (n - 1)


OUTPUT: 

fun odd
  (n : int) =
  (if `= (n, 0) then false
  else
  (if `= (n, 1) then true
  else
  even (`- (n, 1)))
  : int)
and even
  (n : int) =
  (if `= (n, 0) then true
  elif
  `= (n, 1)
    then
    false
  else
  odd (`- (n, 1))
  : int)
EXPECTED: 

fun odd
  (n : int) =
  (if `= (n, 0) then false
  else
  (if `= (n, 1) then true
  else
  even (`- (n, 1)))
  : int)
and even
  (n : int) =
  (if `= (n, 0) then true
  elif
  `= (n, 1)
    then
    false
  else
  odd (`- (n, 1))
  : int)
--------------------------------------------------------
[ OK ]   polylist.hopix

INPUT:

type list ('a) = Cons ('a, list('a)) | Nil

fun map ['a] (f, l) : list('a) =
  l ?
  | Nil => Nil ['a]
  | Cons (x, xs) => Cons ['a] (f (x), map ['a] (f, xs))

fun append ['a] (l1, l2) : list('a) =
  l1 ? Nil => l2
     | Cons (x, xs) => Cons ['a] (x, append ['a] (xs, l2))

val test = map [int] (\(x) => x+1, Cons [int] (3, Nil [int]))
OUTPUT: 

type list ('a) = Cons ('a , list ('a)) | Nil
fun map
  ['a] (f, l) =
  (l ?
  {
  | Nil => Nil['a]
  | Cons (x, xs) => Cons['a] (f (x), map['a] (f, xs))
  }
  : list ('a))
fun append
  ['a] (l1, l2) =
  (l1 ?
  {
  | Nil => l2
  | Cons (x, xs) => Cons['a] (x, append['a] (xs, l2))
  }
  : list ('a))
val test = map[int] (\(x) => `+ (x, 1), Cons[int] (3, Nil[int]))
EXPECTED: 

type list ('a) = Cons ('a , list ('a)) | Nil
fun map
  ['a] (f, l) =
  (l ?
  {
  | Nil => Nil['a]
  | Cons (x, xs) => Cons['a] (f (x), map['a] (f, xs))
  }
  : list ('a))
fun append
  ['a] (l1, l2) =
  (l1 ?
  {
  | Nil => l2
  | Cons (x, xs) => Cons['a] (x, append['a] (xs, l2))
  }
  : list ('a))
val test = map[int] (\(x) => `+ (x, 1), Cons[int] (3, Nil[int]))
--------------------------------------------------------
[ OK ]   pri_app.hopix

INPUT:

{- priority of application : trivial with this year's syntax -}

val x = f(a) + b
val x = f(a) := b
val x = f(g,a)

val x = f(x)(y)
val x = f[int](x)[bool](b)

val x = f(x) ? _ => 1
OUTPUT: 

val x = `+ (f (a), b)
val x = f (a) := b
val x = f (g, a)
val x = f (x) (y)
val x = f[int] (x)[bool] (b)
val x = f (x) ? { | _ => 1 }
EXPECTED: 

val x = `+ (f (a), b)
val x = f (a) := b
val x = f (g, a)
val x = f (x) (y)
val x = f[int] (x)[bool] (b)
val x = f (x) ? { | _ => 1 }
--------------------------------------------------------
[ OK ]   pri_arith.hopix

INPUT:

{- Arithmetical priorities -}

val x = 1+2+3
val x = 1+2-3-4+5
val x = 1*2*3
val x = 1/2/3
val x = 1*2/3/4*5
val x = 1+2*3-4
val x = 1+2*3-4/5+6
val x = (1+2)*3

OUTPUT: 

val x = `+ (`+ (1, 2), 3)
val x = `+ (`- (`- (`+ (1, 2), 3), 4), 5)
val x = `* (`* (1, 2), 3)
val x = `/ (`/ (1, 2), 3)
val x = `* (`/ (`/ (`* (1, 2), 3), 4), 5)
val x = `- (`+ (1, `* (2, 3)), 4)
val x = `+ (`- (`+ (1, `* (2, 3)), `/ (4, 5)), 6)
val x = `* (`+ (1, 2), 3)
EXPECTED: 

val x = `+ (`+ (1, 2), 3)
val x = `+ (`- (`- (`+ (1, 2), 3), 4), 5)
val x = `* (`* (1, 2), 3)
val x = `/ (`/ (1, 2), 3)
val x = `* (`/ (`/ (`* (1, 2), 3), 4), 5)
val x = `- (`+ (1, `* (2, 3)), 4)
val x = `+ (`- (`+ (1, `* (2, 3)), `/ (4, 5)), 6)
val x = `* (`+ (1, 2), 3)
--------------------------------------------------------
[ OK ]   pri_arith1.hopix

INPUT:
val x = 1+2+3

OUTPUT: 

val x = `+ (`+ (1, 2), 3)
EXPECTED: 

val x = `+ (`+ (1, 2), 3)
--------------------------------------------------------
[ OK ]   pri_arith2.hopix

INPUT:
val x = 1+2-3-4+5

OUTPUT: 

val x = `+ (`- (`- (`+ (1, 2), 3), 4), 5)
EXPECTED: 

val x = `+ (`- (`- (`+ (1, 2), 3), 4), 5)
--------------------------------------------------------
[ OK ]   pri_arith3.hopix

INPUT:
val x = 1*2*3

OUTPUT: 

val x = `* (`* (1, 2), 3)
EXPECTED: 

val x = `* (`* (1, 2), 3)
--------------------------------------------------------
[ OK ]   pri_arith4.hopix

INPUT:
val x = 1/2/3

OUTPUT: 

val x = `/ (`/ (1, 2), 3)
EXPECTED: 

val x = `/ (`/ (1, 2), 3)
--------------------------------------------------------
[ OK ]   pri_arith5.hopix

INPUT:
val x = 1*2/3/4*5

OUTPUT: 

val x = `* (`/ (`/ (`* (1, 2), 3), 4), 5)
EXPECTED: 

val x = `* (`/ (`/ (`* (1, 2), 3), 4), 5)
--------------------------------------------------------
[ OK ]   pri_arith6.hopix

INPUT:
val x = 1+2*3-4

OUTPUT: 

val x = `- (`+ (1, `* (2, 3)), 4)
EXPECTED: 

val x = `- (`+ (1, `* (2, 3)), 4)
--------------------------------------------------------
[ OK ]   pri_arith7.hopix

INPUT:
val x = 1+2*3-4/5+6

OUTPUT: 

val x = `+ (`- (`+ (1, `* (2, 3)), `/ (4, 5)), 6)
EXPECTED: 

val x = `+ (`- (`+ (1, `* (2, 3)), `/ (4, 5)), 6)
--------------------------------------------------------
[ OK ]   pri_arith8.hopix

INPUT:
val x = (1+2)*3

OUTPUT: 

val x = `* (`+ (1, 2), 3)
EXPECTED: 

val x = `* (`+ (1, 2), 3)
--------------------------------------------------------
[ OK ]   pri_bang.hopix

INPUT:
{- priority of := -}

val x = !r + 2
val x = !r || false

val x = !u ? _ => 1
val x = !(u ? _ => 1)

val x = !!u

val x = !u; v

val x = ! rf(1,2)
val x = (!rf) (1,2)
OUTPUT: 

val x = `+ (! r, 2)
val x = `|| (! r, false)
val x = (! u) ? { | _ => 1 }
val x = ! (u ? { | _ => 1 })
val x = ! (! u)
val x = val nothing = (! u) ; v
val x = ! rf (1, 2)
val x = (! rf) (1, 2)
EXPECTED: 

val x = `+ (! r, 2)
val x = `|| (! r, false)
val x = (! u) ? { | _ => 1 }
val x = ! (u ? { | _ => 1 })
val x = ! (! u)
val x = val nothing = (! u) ; v
val x = ! rf (1, 2)
val x = (! rf) (1, 2)
--------------------------------------------------------
[ OK ]   pri_comp.hopix

INPUT:

{- Priorities of comparisons and boolean operators -}

val x = 2 = 1 + 1

val x = true || true || true && true && true

val x = 1 + 1 < 2 + 2 && 4 = 7

OUTPUT: 

val x = `= (2, `+ (1, 1))
val x = `|| (`|| (true, true), `&& (`&& (true, true), true))
val x = `&& (`< (`+ (1, 1), `+ (2, 2)), `= (4, 7))
EXPECTED: 

val x = `= (2, `+ (1, 1))
val x = `|| (`|| (true, true), `&& (`&& (true, true), true))
val x = `&& (`< (`+ (1, 1), `+ (2, 2)), `= (4, 7))
--------------------------------------------------------
[ OK ]   pri_comp1.hopix

INPUT:

{- Priorities of comparisons and boolean operators -}

val x = 2 = 1 + 1


OUTPUT: 

val x = `= (2, `+ (1, 1))
EXPECTED: 

val x = `= (2, `+ (1, 1))
--------------------------------------------------------
[ OK ]   pri_comp2.hopix

INPUT:
val x = true || true || true && true && true

OUTPUT: 

val x = `|| (`|| (true, true), `&& (`&& (true, true), true))
EXPECTED: 

val x = `|| (`|| (true, true), `&& (`&& (true, true), true))
--------------------------------------------------------
[ OK ]   pri_comp3.hopix

INPUT:
val x = 1 + 1 < 2 + 2 && 4 = 7

OUTPUT: 

val x = `&& (`< (`+ (1, 1), `+ (2, 2)), `= (4, 7))
EXPECTED: 

val x = `&& (`< (`+ (1, 1), `+ (2, 2)), `= (4, 7))
--------------------------------------------------------
[ OK ]   pri_infix.hopix

INPUT:

{- priority of infix operators -}

val x = 1 = 1 `op` 2 `op` 3 + 3

OUTPUT: 

val x = `= (1, `op (`op (1, 2), `+ (3, 3)))
EXPECTED: 

val x = `= (1, `op (`op (1, 2), `+ (3, 3)))
--------------------------------------------------------
[ OK ]   pri_qmark.hopix

INPUT:
{- priority of ? -}

val x = x * x ? _ => 3
val x = x := a ? _ => 3

OUTPUT: 

val x = `* (x, x ? { | _ => 3 })
val x = x := a ? { | _ => 3 }
EXPECTED: 

val x = `* (x, x ? { | _ => 3 })
val x = x := a ? { | _ => 3 }
--------------------------------------------------------
[ OK ]   pri_qmark1.hopix

INPUT:
{- priority of ? -}
val x = x * x ? _ => 3

OUTPUT: 

val x = `* (x, x ? { | _ => 3 })
EXPECTED: 

val x = `* (x, x ? { | _ => 3 })
--------------------------------------------------------
[ OK ]   pri_qmark2.hopix

INPUT:
val x = x := a ? _ => 3

OUTPUT: 

val x = x := a ? { | _ => 3 }
EXPECTED: 

val x = x := a ? { | _ => 3 }
--------------------------------------------------------
[ OK ]   pri_rarrow.hopix

INPUT:

{- priority of => -}

val x = \(x) => x + x
val x = \(x) => x && x

val x = \(x) => x := 1
val x = \(x) => (x := 1)
val x = (\(x) => x) := 1 {-- badly typed --}

val x =
 val f = \(x) => x;
 f

val x = \(x) => x; y

val x =
  fun f (y) = y ? _ => 1;
  f(1)

val x =
  val y = z ? _ => 1; y

OUTPUT: 

val x = \(x) => `+ (x, x)
val x = \(x) => `&& (x, x)
val x = \(x) => x := 1
val x = \(x) => x := 1
val x = (\(x) => x) := 1
val x = val f = (\(x) => x) ; f
val x = val nothing = (\(x) => x) ; y
val x = fun f (y) = (y ? { | _ => 1 }) ; f (1)
val x = val y = (z ? { | _ => 1 }) ; y
EXPECTED: 

val x = \(x) => `+ (x, x)
val x = \(x) => `&& (x, x)
val x = \(x) => x := 1
val x = \(x) => x := 1
val x = (\(x) => x) := 1
val x = val f = (\(x) => x) ; f
val x = val nothing = (\(x) => x) ; y
val x = fun f (y) = (y ? { | _ => 1 }) ; f (1)
val x = val y = (z ? { | _ => 1 }) ; y
--------------------------------------------------------
[ OK ]   pri_rarrow1.hopix

INPUT:

{- priority of => -}

val x = \(x) => x + x

OUTPUT: 

val x = \(x) => `+ (x, x)
EXPECTED: 

val x = \(x) => `+ (x, x)
--------------------------------------------------------
[ OK ]   pri_rarrow2.hopix

INPUT:
val x = \(x) => x && x

OUTPUT: 

val x = \(x) => `&& (x, x)
EXPECTED: 

val x = \(x) => `&& (x, x)
--------------------------------------------------------
[ OK ]   pri_rarrow3.hopix

INPUT:

val x = \(x) => x := 1

OUTPUT: 

val x = \(x) => x := 1
EXPECTED: 

val x = \(x) => x := 1
--------------------------------------------------------
[ OK ]   pri_rarrow4.hopix

INPUT:

val x =
 val f = \(x) => x;
 f

OUTPUT: 

val x = val f = (\(x) => x) ; f
EXPECTED: 

val x = val f = (\(x) => x) ; f
--------------------------------------------------------
[ OK ]   pri_rarrow5.hopix

INPUT:

val x =
  fun f (y) = y ? _ => 1;
  f(1)

OUTPUT: 

val x = fun f (y) = (y ? { | _ => 1 }) ; f (1)
EXPECTED: 

val x = fun f (y) = (y ? { | _ => 1 }) ; f (1)
--------------------------------------------------------
[ OK ]   pri_ref.hopix

INPUT:
{- priority of := -}

val x = ref 1 + 2
val x = ref (1 + 2)

val x = ref u ? _ => 1
val x = (ref u) ? _ => 1

val x = ref ref u

val x = ref u; v

val x = ref u := v
val x = ref (u := v)

val x = ref f (x)
val x = (ref f) (x)
OUTPUT: 

val x = `+ (ref 1, 2)
val x = ref `+ (1, 2)
val x = ref (u ? { | _ => 1 })
val x = (ref u) ? { | _ => 1 }
val x = ref (ref u)
val x = val nothing = (ref u) ; v
val x = ref (u := v)
val x = ref (u := v)
val x = ref f (x)
val x = (ref f) (x)
EXPECTED: 

val x = `+ (ref 1, 2)
val x = ref `+ (1, 2)
val x = ref (u ? { | _ => 1 })
val x = (ref u) ? { | _ => 1 }
val x = ref (ref u)
val x = val nothing = (ref u) ; v
val x = ref (u := v)
val x = ref (u := v)
val x = ref f (x)
val x = (ref f) (x)
--------------------------------------------------------
[ OK ]   pri_scolon.hopix

INPUT:
{- priority of ; -}

val x =
  val y = 1 + 1 ;
  y + y

val x =
  val y = true ;
  y || y

val x =
  val y = 1 ; y ? _ => 2

OUTPUT: 

val x = val y = `+ (1, 1) ; `+ (y, y)
val x = val y = true ; `|| (y, y)
val x = val y = 1 ; y ? { | _ => 2 }
EXPECTED: 

val x = val y = `+ (1, 1) ; `+ (y, y)
val x = val y = true ; `|| (y, y)
val x = val y = 1 ; y ? { | _ => 2 }
--------------------------------------------------------
[ OK ]   pri_scolon1.hopix

INPUT:
{- priority of ; -}

val x =
  val y = 1 + 1 ;
  y + y
OUTPUT: 

val x = val y = `+ (1, 1) ; `+ (y, y)
EXPECTED: 

val x = val y = `+ (1, 1) ; `+ (y, y)
--------------------------------------------------------
[ OK ]   pri_scolon2.hopix

INPUT:
val x =
  val y = true ;
  y || y

OUTPUT: 

val x = val y = true ; `|| (y, y)
EXPECTED: 

val x = val y = true ; `|| (y, y)
--------------------------------------------------------
[ OK ]   pri_scolon3.hopix

INPUT:
val x =
  val y = 1 ; y ? _ => 2

OUTPUT: 

val x = val y = 1 ; y ? { | _ => 2 }
EXPECTED: 

val x = val y = 1 ; y ? { | _ => 2 }
--------------------------------------------------------
[ OK ]   pri_set.hopix

INPUT:
{- priority of := -}

val x = t := 1 + 2
val x = t := true || false

val x = t := u ? _ => 1
val x = (t := u) ? _ => 1

val x = t := u := 1
val x = (t := u) := 1

val x = x := u; v

val x = ref u := v
val x = ref (u := v)

val x = u + u := v
val x = (u+u) := v

val x = if b then r := 1
val x = (if b then r) := 1
OUTPUT: 

val x = t := `+ (1, 2)
val x = t := `|| (true, false)
val x = t := u ? { | _ => 1 }
val x = (t := u) ? { | _ => 1 }
val x = t := u := 1
val x = (t := u) := 1
val x = val nothing = (x := u) ; v
val x = ref (u := v)
val x = ref (u := v)
val x = `+ (u, u := v)
val x = `+ (u, u) := v
val x = if b then r := 1
val x = (if b then r) := 1
EXPECTED: 

val x = t := `+ (1, 2)
val x = t := `|| (true, false)
val x = t := u ? { | _ => 1 }
val x = (t := u) ? { | _ => 1 }
val x = t := u := 1
val x = (t := u) := 1
val x = val nothing = (x := u) ; v
val x = ref (u := v)
val x = ref (u := v)
val x = `+ (u, u := v)
val x = `+ (u, u) := v
val x = if b then r := 1
val x = (if b then r) := 1
--------------------------------------------------------
[ OK ]   pri_set1.hopix

INPUT:
{- priority of := -}

val x = t := 1 + 2

OUTPUT: 

val x = t := `+ (1, 2)
EXPECTED: 

val x = t := `+ (1, 2)
--------------------------------------------------------
[ OK ]   pri_set2.hopix

INPUT:
val x = t := true || false

OUTPUT: 

val x = t := `|| (true, false)
EXPECTED: 

val x = t := `|| (true, false)
--------------------------------------------------------
[ OK ]   pri_set3.hopix

INPUT:
val x = t := t ? _ => 1

OUTPUT: 

val x = t := t ? { | _ => 1 }
EXPECTED: 

val x = t := t ? { | _ => 1 }
--------------------------------------------------------
[ OK ]   recfun.hopix

INPUT:
fun fact (n : int) : int =
  if n = 0 then 1 else n * fact (n - 1)


OUTPUT: 

fun fact
  (n : int) =
  (if `= (n, 0) then 1
  else
  `* (n, fact (`- (n, 1)))
  : int)
EXPECTED: 

fun fact
  (n : int) =
  (if `= (n, 0) then 1
  else
  `* (n, fact (`- (n, 1)))
  : int)
--------------------------------------------------------
[ OK ]   types.hopix

INPUT:
type some_abstract_type
type unit = Unit
type list = Cons (int, list) | Nil
type option ('a) = None | Some ('a)
type prod ('a, 'b) = Pair ('a, 'b)
type either ('a, 'b) = Left ('a) | Right ('b)
type stream ('a) = Next (unit -> prod('a,stream('a)))
type t1 = T1 ((option(int) -> int) -> int -> int)
type t2 = T2 (either (int, option (int)))
OUTPUT: 

type some_abstract_type  
type unit  = Unit
type list  = Cons (int , list) | Nil
type option ('a) = None | Some ('a)
type prod ('a, 'b) = Pair ('a , 'b)
type either ('a, 'b) = Left ('a) | Right ('b)
type stream ('a) = Next (unit -> prod ('a, stream ('a)))
type t1  = T1 ((option (int) -> int) -> int -> int)
type t2  = T2 (either (int, option (int)))
EXPECTED: 

type some_abstract_type  
type unit  = Unit
type list  = Cons (int , list) | Nil
type option ('a) = None | Some ('a)
type prod ('a, 'b) = Pair ('a , 'b)
type either ('a, 'b) = Left ('a) | Right ('b)
type stream ('a) = Next (unit -> prod ('a, stream ('a)))
type t1  = T1 ((option (int) -> int) -> int -> int)
type t2  = T2 (either (int, option (int)))
--------------------------------------------------------
[ OK ]   types1.hopix

INPUT:
type some_abstract_type

OUTPUT: 

type some_abstract_type  
EXPECTED: 

type some_abstract_type  
--------------------------------------------------------
[ OK ]   types3.hopix

INPUT:
type unit = Unit

OUTPUT: 

type unit  = Unit
EXPECTED: 

type unit  = Unit
--------------------------------------------------------
[ OK ]   types4.hopix

INPUT:
type list = Cons (int, list) | Nil

OUTPUT: 

type list  = Cons (int , list) | Nil
EXPECTED: 

type list  = Cons (int , list) | Nil
--------------------------------------------------------
[ OK ]   types5.hopix

INPUT:
type option ('a) = None | Some ('a)

OUTPUT: 

type option ('a) = None | Some ('a)
EXPECTED: 

type option ('a) = None | Some ('a)
--------------------------------------------------------
[ OK ]   types6.hopix

INPUT:
type either ('a, 'b) = Left ('a) | Right ('b)

OUTPUT: 

type either ('a, 'b) = Left ('a) | Right ('b)
EXPECTED: 

type either ('a, 'b) = Left ('a) | Right ('b)
--------------------------------------------------------
[ OK ]   types7.hopix

INPUT:
type stream ('a) = Next (unit -> prod ('a, stream('a)))

OUTPUT: 

type stream ('a) = Next (unit -> prod ('a, stream ('a)))
EXPECTED: 

type stream ('a) = Next (unit -> prod ('a, stream ('a)))
--------------------------------------------------------
[ OK ]   types8.hopix

INPUT:
type t1 = T1 ((option (int) -> int) -> int -> int)

OUTPUT: 

type t1  = T1 ((option (int) -> int) -> int -> int)
EXPECTED: 

type t1  = T1 ((option (int) -> int) -> int -> int)
--------------------------------------------------------
[ OK ]   types9.hopix

INPUT:
type t2 = T2 (either (int, option (int)))
OUTPUT: 

type t2  = T2 (either (int, option (int)))
EXPECTED: 

type t2  = T2 (either (int, option (int)))
--------------------------------------------------------
[ OK ]   while.hopix

INPUT:
val while1 = while x { a; b  }
val while2 = while 1=1 { a; b }
val while3 = while f (x) { a; b }
val while4 = while a; b { c; d }

OUTPUT: 

val while1 = while x {  val nothing = a ; b  }
val while2 = while `= (1, 1) {  val nothing = a ; b  }
val while3 = while f (x) {  val nothing = a ; b  }
val while4 =
  while (val nothing = a ; b) {  val nothing = c ; d  }
EXPECTED: 

val while1 = while x {  val nothing = a ; b  }
val while2 = while `= (1, 1) {  val nothing = a ; b  }
val while3 = while f (x) {  val nothing = a ; b  }
val while4 =
  while (val nothing = a ; b) {  val nothing = c ; d  }
--------------------------------------------------------
GOOD: 134 / 135
BAD:  0 / 0
make[1]: Leaving directory '/home/opam/source/flap/tests-m1/hopix/parser/good'
--------------------------------------------------------
Global results:
BAD:   7 / 7
GOOD:  134 / 135
--------------------------------------------------------
make: Leaving directory '/home/opam/source/flap/tests-m1'
